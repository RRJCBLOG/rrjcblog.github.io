{"pages":[{"url":"suan-fa/算法.html","text":"分布式UUID算法snowflake 概述 分布式系统中，有一些需要使用全局唯一ID的场景，这种时候为了防止ID冲突可以使用36位的UUID，但是UUID有一些缺点，首先他相对比较长，另外UUID一般是无序的，而且不是纯数字的。 有些时候我们希望能使用一种简单一些的ID，保持纯数字，并且希望ID能够按照时间有序生成。 而twitter的snowflake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra，因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一ID生成服务。 结构 snowflake的结构如下(每部分用-分开): 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） ，最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号） 一共加起来刚好64位，为一个Long型。(转换成字符串长度为18) snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。snowflake每秒能够产生26万个ID。 ok, let's shut up , just show me the code! package com.rrjc.pf.common ; import java.net.InetAddress ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; /** * (a) id构成: 42位的时间前缀 + 10位的节点标识 + 12位的sequence避免并发的数字(12位不够用时强制得到新的时间前缀) * 注意这里进行了小改动: snowkflake是5位的datacenter加5位的机器id; 这里变成使用10位的机器id * (b) 对系统时间的依赖性非常强，需关闭ntp的时间同步功能。当检测到ntp时间调整后，将会拒绝分配id */ public class IdWorker { private final static Logger logger = LoggerFactory . getLogger ( IdWorker . class ); private final long workerId ; private final long epoch = 1403854494756L ; // 时间起始标记点，作为基准，一般取系统的最近时间 private final long workerIdBits = 10L ; // 机器标识位数 private final long maxWorkerId = - 1L &#94; - 1L << this . workerIdBits ; // 机器ID最大值: 1023 private long sequence = 0 L ; // 0，并发控制 private final long sequenceBits = 12L ; //毫秒内自增位 private final long workerIdShift = this . sequenceBits ; // 12 private final long timestampLeftShift = this . sequenceBits + this . workerIdBits ; // 22 private final long sequenceMask = - 1L &#94; - 1L << this . sequenceBits ; // 4095,111111111111,12位 private long lastTimestamp = - 1L ; private IdWorker ( long workerId ) { if ( workerId > this . maxWorkerId || workerId < 0 ) { throw new IllegalArgumentException ( String . format ( \"worker Id can't be greater than %d or less than 0\" , this . maxWorkerId )); } this . workerId = workerId ; } public synchronized long nextId () throws Exception { long timestamp = IdWorker . timeGen (); if ( this . lastTimestamp == timestamp ) { // 如果上一个timestamp与新产生的相等，则sequence加一(0-4095循环); 对新的timestamp，sequence从0开始 this . sequence = this . sequence + 1 & this . sequenceMask ; if ( this . sequence == 0 ) { timestamp = this . tilNextMillis ( this . lastTimestamp ); // 重新生成timestamp } } else { this . sequence = 0 ; } if ( timestamp < this . lastTimestamp ) { logger . error ( String . format ( \"clock moved backwards.Refusing to generate id for %d milliseconds\" , ( this . lastTimestamp - timestamp ))); throw new Exception ( String . format ( \"clock moved backwards.Refusing to generate id for %d milliseconds\" , ( this . lastTimestamp - timestamp ))); } this . lastTimestamp = timestamp ; return timestamp - this . epoch << this . timestampLeftShift | this . workerId << this . workerIdShift | this . sequence ; } private static IdWorker flowIdWorker = new IdWorker ( getworkerHostIp ()); public static IdWorker getFlowIdWorkerInstance () { return flowIdWorker ; } /** * 等待下一个毫秒的到来, 保证返回的毫秒数在参数lastTimestamp之后 */ private long tilNextMillis ( long lastTimestamp ) { long timestamp = IdWorker . timeGen (); while ( timestamp <= lastTimestamp ) { timestamp = IdWorker . timeGen (); } return timestamp ; } /** * 获得系统当前毫秒数 */ private static long timeGen () { return System . currentTimeMillis (); } /** * * @param bytes * @return int */ public static int getworkerHostIp () { try { byte [] bytes = InetAddress . getLocalHost (). getAddress (); return Integer . valueOf ( bytes [ 3 ] & 0xFF ); } catch ( Exception e ) { logger . error ( e . getMessage (), e ); return 1 ; } } public static void main ( String [] args ) throws Exception { IdWorker idWorker = IdWorker . getFlowIdWorkerInstance (); System . out . println ( idWorker . nextId ()); System . out . println ( idWorker . nextId ()); } } 经5万的并发，亦不会有重复的id出现。","tags":"算法","title":"分布式UUID算法snowflake"},{"url":"gao-ke-yong-jia-gou/API限流.html","text":"最初发生这种情况时，对基础架构进行扩容以适应增长是合理的。 但是在 API 服务生产环境中，需要针对具体规模来进行设计和构建，并确保任何坏因素不会影响其可用性。 限制流量可以使 API 服务在下面的场景中更可靠： 某个用户直接或间接造成了流量飙升，我们需要确保对其他用户服务可用。 某个用户向 API 服务发送大量请求。 或者更糟的是，某个用户试图恶意冲垮服务器。 用户发送了大量低优先级请求，但我们希望确保不会影响其他高优先级请求。 例如，发送大量分析数据请求的用户可能会影响其他用户的关键事务。 系统内部产生错误，导致无法处理所有请求，不得不丢弃低优先级的请求。 在 Stripe，通过细致的设计和实现一些限流策略，保障了我们的 API 服务对所有用户的可用性。在这篇文章中，我们将详细介绍这些限流策略、如何对 API 请求进行优先级划分，以及如何安全地使用限流器而不影响现有用户的工作流程。 限流器和负载降级 限流器用于控制在网络上发送或接收的流量速率。什么时候应该使用限流器？If your users can afford to change the pace at which they hit your API endpoints without affecting the outcome of their requests（小编：这句话翻译起来太拗口了，小编的理解限流首先是保护服务提供方，然后不会伤害正常的服务使用方），那么使用限速器就是合适的。如果在请求与请求之间插入间隔不可行，比如对于实时通信场景，那么则需要另外的策略（这超出了此文章的范围，但通常来说需要对基础设施扩容）。 用户可以产生很多请求：例如，批处理支付请求会导致 API 流量持续升高。用户总是可以扩展他们的请求，而不受限流器的影响。 限流器对于大部分使用场景是十分高效的，但有时我们需要完全丢弃低优先级的请求，以确保更多关键请求的处理，这称为负载降级（load shedder）。 负载降级可以根据系统的整体状态而不是正在请求的用户来进行决策。它可以帮助我们应对突发事件，确保核心部分正常工作。 使用不同类型的限流器 我们应该根据场景决定使用何种限流器，以确保其最大程度提高 API 服务的可靠性。 在 Stripe，我们在生产环境中使用4种不同类型的限流器。 第一种，请求限流器，它也是最重要的一个。 请求限流器 该限流器限制每个用户每秒可发送 N 个请求。 我们的请求限流器在本月已经拒绝了数百万个请求，特别是对于用户无意运行脚本产生的测试请求。 我们的 API 在测试和生产模式下提供相同的速率/流量限制行为。 这样做有利于开发人员的体验：在从开发切换到生产模式时，程序或脚本不会遇到副作用。 在分析了我们的流量模式之后，我们为请求限流器增加了适应请求激增的能力，比如用于电商中的抢购。","tags":"高可用架构","title":"API限流设计"},{"url":"wang-luo-an-quan/弱口令.html","text":"弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。 弱口令指的是仅包含简单数字和字母的口令，例如\"123\"、\"abc\"等，因为这样的口令很容易被别人破解，从而使用户的互联网账号受到他人控制，因此不推荐用户使用。 0×01 为什么会产生弱口令 这个应该是与个人习惯相关与意识相关，为了避免忘记密码，使用一个非常容易记住的密码，或者是直接采用系统的默认密码等。 相关的安全意识不够，总认为不会有人会猜到我这个弱口令的。 0×02 弱口令的危害 在当今很多地方以用户名(帐号)和口令作为鉴权的世界，口令的重要性就可想而知了。 口令就相当于进入家门的钥匙，当他人有一把可以进入你家的钥匙，想想你的安全、你的财物、你的隐私。 因为弱口令很容易被他人猜到或破解，所以如果你使用弱口令，就像把家门钥匙放在家门口的垫子下面，是非常危险的。 那么互联网上到底存在多少弱口令或默认密码呢？ 截止到写此文章开始，乌云提交平台上弱口令相关漏洞已经多达778个，除了泄露数据以外，其中不少可以利用弱口令而获取服务器权限","tags":"网络安全","title":"浅谈互联网中弱口令的危害"},{"url":"linux/CVE2017-2636.html","text":"CVE2017-2636 又一个古老的Linux内核漏洞被曝光！这次的漏洞可以追溯到2009年，影响的linux发行版包括Red Hat、Debian、Fedora、OpenSUSE和Ubuntu。 这个Linux漏洞编号为CVE-2017-2636，根据CVSS v3标准漏洞评分为7.8分。漏洞在Linux内核已经存在7年了，它能够让本地无权限的用户获取root权限，或者发动DoS让系统崩溃。 Positive Technologies的研究员Alexander Popov发现了存在于N_HLDC linux内核驱动的竞争条件问题。 这个内核驱动负责处理高级数据链路控制（High-Level Data Link Control或简称HDLC）数据。问题导致了double-free漏洞。 Double Free其实就是同一个指针free两次。虽然一般把它叫做double free，其实只要是free一个指向堆内存的指针都有可能产生可以利用的漏洞。 \"这是CVE-2017-2636的声明，该漏洞即N_HLDC (drivers/tty/n_hdlc.c) linux内核驱动中的竞争条件。这个漏洞可以用来进行本地提权。\"SecList的安全公告提到。 \"该驱动提供HDLC串行线路规程，这是很多linux发行版中的内核模块——只要是内核设置中有CONFIG_N_HDLC=m的linux发行版。要利用这个漏洞不需要Microgate或者SyncLink硬件。当没有权限的用户打开伪终端并且调用TIOCSETD ioctl函数设置HDLC串行线路规程的时候，模块就会自动加载。\" 因此未经授权的攻击者可以利用这个漏洞注入执行任意代码。 影响范围 这个漏洞影响的范围涵盖大多数主流的Linux发行版，包括Red Hat Enterprise Linux 6, 7, Fedora, SUSE, Debian和Ubuntu。 由于漏洞可以追溯至2009年7月，那些Linux设备存在漏洞长达7年了，但是根据Positive Technologies的调查，很难确定漏洞是否已经被利用过。 \"漏洞非常老，所以在Linux工作站和服务器中传播广泛。\"Popov说道，\"要想利用漏洞，攻击者只需要没有权限的普通用户就行了。另外，攻击不需要任何特殊的硬件。\" 研究人员在用syzkaller fuzzer进行系统调用测试的时候发现了这个漏洞。syzkaller fuzzer是由Google开发的代码安全审计软件。 Popov于是在2017年2月28日将漏洞细节、exp原型和补丁上报给了kernel.org。Popov称会在之后公布PoC。 修复建议 该漏洞目前已经修复，更新和漏洞详情均在3月7日公布。建议用户尽快下载安全更新。如果暂时无法安装更新，建议手动关闭n_hdlc模块。","tags":"Linux","title":"CVE-2017-2636"}]}